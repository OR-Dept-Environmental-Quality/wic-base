---
title: "Another WIC example analysis using R Markdown"
output:
  word_document: default
  html_document:
    df_print: paged
---

by Martin Brown, [Martin.Brown@state.or.us]()

### Introduction

This (relatively) short R Markdown document provides a simple example of using the WIC framework to predict the environmental consequences of solid waste decisions.  This document does not contain the extensive documentation and explanation available in other parts of the WIC-base repository... it is meant for those who already have grasped the basic elements of the WIC framework and simply wish to see another example.

### The management question

The City of Gresham, Oregon currently collects yard debris from residences and composts it relatively close to town -- about 4 miles away.  It does not currently collect food waste for composting. Food waste is included in the general trash bin and taken to a landfill 178 miles away.

Gresham would like to allow the addition of food waste to yard debris collections so that they could be composted together.  Gresham anticipates this would reduce the life cycle impacts of the food waste.  However, the nearby composting facility cannot take food waste (it is near an airport and there are fears any birds attracted might interfere with airplanes).  The mixed yard debris and food waste would need to be taken to another facility, 78 miles away.

Two questions should be answered:

* assuming total tonnage of materials stay the same, but some food waste is sent with yard debris for composting at the more distant site, how would life cycle impacts of the materials change?
* could the same impact reductions be achieved by a modest reduction in food waste generation?

This should be a relatively straightforward application of WIC, but there is one twist: Gresham is unsure of how much food waste is really part of the system.  I have constructed an estimate for Gresham.  In the massProfiles table, I have assumed that in the baseline (current) case, the ratio of food waste generation to yard debris generation for Gresham is the same as for the whole "Metro" wasteshed.  I have scaled these numbers so that there are 9000 tons of yard debris, and a suitable number of tons of food waste, in the baseline case.  Here are the scenarios analyzed:

* baseline (current management, all yard debris to composting, 4 miles away, and all food waste to landfill, 178 miles away)
* compost_1000t (send 1000 tons of food waste, and all yard debris, to the site 78 miles away -- rest of food waste to landfill)
* compost_6pt5pct (send food waste equivalent to 6.5 percent of yard debris tonnage, and all yard debris, to the site 78 miles away -- rest of food waste to landfill)
* reduce_fw_05pct (same as current management but 5 percent less food waste generated)
* reduct_fw_10pct (same as current management but 10 percent less food waste generated)

### Preparing the R workspace

```{r}
# checking working directory
getwd()

# loading packages useful for the analysis
library(tidyverse)  # many useful functions for data management
library(readxl)     # imports Excel files
library(ggthemes)   # some themes for plotting
library(scales)     # useful functions for labeling charts
library(knitr)      # helps generate formatted output of various kinds
library(rmarkdown)  # converts RMarkdown documents to other formats
library(viridis)    # nice & accessible color schemes
library(svglite)    # helps write charts to SVG files
```

### Loading *massProfiles* and *impactFactors*

Here we load the massProfiles table into an R data frame, and print it out in a formatted table.

```{r}
# loading the mass profile data into an R data frame
massProfiles <-
  read_excel(
    path="MassProfiles.xlsx",
    sheet="gresham mass profiles"
  ) %>%
  select(-notes)
# a formatted printout
kable(
  massProfiles, 
  caption="management scenarios for Gresham"
)
```

Here is the summed number of tons of waste within each scenario:
```{r}
massProfiles %>%
  group_by(scenario) %>%
  summarize(tons=sum(tons)) %>%
  kable()
```
I see some tiny differences between the first three scenarios, which shouldn't be there, but they are so small as to be forgiven. The last two scenarios have fewer tons because they involve reduction in generation.

Here is a similar table with a bit more detail about what happens to all that waste at end of life:

```{r}
massProfiles %>%
  group_by(scenario, material, disposition) %>%
  summarize(tons=sum(tons)) %>%
  kable()
```

This example illustrates an important quality of the Waste Impact Calculator.  As you recall from the *Technical Overview*, the tons, dispositions, and miles listed in massProfiles *are the ONLY data* that distinguish solid waste management scenarios from one another.  All of the user's waste management ideas must be expressed in the massProfiles data frame!  For example, a waste management scenario that increases recycling compared to baseline should have more tons associated with recycling dispositions, and less tons associated with disposal dispositions.

Here is an example of how massProfile information expresses the difference between solid waste management scenarios, "baseline" and "eliminate_food_waste":

```{r}
massProfiles %>%
  filter(
    scenario=="baseline" | scenario=="eliminate_food_waste"
    ) %>%
  kable()
```

WIC's other source data table is *impactFactors*.  Here we load the impactFactors table into an R data frame and print it out in a formatted table.  The impactFactors table is typically thousands of records long, but for brevity in this example analysis, we filter it to only 2 materials and 2 impact categories.

```{r}
# loading the impact factor data into an R data frame
impactFactors <-
  read.csv(
    file = "../impactFactors/distributable/impactFactors.csv", 
    header = TRUE, 
    stringsAsFactors = FALSE  #
  ) %>%
  # for the sake of brevity in this example analysis ,
  # limiting the impactFactors to two impact categories
  # and two materials.  In regular usage there is no
  # need to do such filtering -- the impactFactors 
  # data frame may be left complete.
  filter(
      (material=="YardDebris" | material=="FoodWaste") 
  ) %>%
  # sorting it for easier reading
  arrange(impactCategory, material, LCstage, disposition)
# a formatted printout
kable(impactFactors)
```
The fields making up impactFactors can be viewed as:

```{r}
str(impactFactors)
```
As you recall from *Technical overview of the Waste Impact Calculator*, the critical field in this table is *impactFactor*.  This number expresses an environmental impact for a particular mass of a particular material in a particular life cycle stage.  All the other variables in each record identify or qualify the impact factor somehow -- e.g. name the material, label its units, etc. 

The impactFactors data frame should have EXACTLY one record for each combination of material, life cycle stage, disposition, and impactCategory of interest.  Though impactFactor tables provided by Oregon DEQ should have this characteristic, you can check it if you desire, for example like this:

```{r}
# checking for rows of impactFactors that might be duplicates
# and printing a summary sentence
print(
  paste(
    "There are ",
    impactFactors %>%
      group_by(material, LCstage, disposition, impactCategory) %>%
      summarise(myCount=n()) %>% # number of rows in each group
      filter(myCount != 1) %>% # keep only rows where count <> 1
      nrow(),
    " rows in impactFactors that need to be inspected for duplicates.",
    sep=""
  )
)
```

### Merging the two tables to produce impactsInDetail.

massProfiles and impactsInDetail will be merged to allow us to calculate impacts, but before we do that we must address a limitation of massProfiles.  So far massProfiles only includes tons of materials handled at the end-of-life phase of the life cycle.  We must also account for the tons of those materials that are handled at two other life cycle stages: end-of-life transport and production.  

We will add tonnages representing production here using a simple copy- and append operation.  In the following code,  all the cases from massProfiles are copied, labeled with a disposition (and umbDisp) of "production," and then added back to massProfiles, creating a new data frame, massProfilesPlus.

```{r}
# copy end-of-life tons and label them as production tons
tempProductionMasses <-
  massProfiles %>%
  mutate(
    disposition="production",
    umbDisp="production",
    miles=NA
  )
# add the production tons to the end-of-life tons
massProfilesPlus <-
  bind_rows(
    massProfiles,
    tempProductionMasses
  ) %>%
  # sort the new, larger table
  arrange(
    scenario, wasteshed, material, disposition
  )
rm(tempProductionMasses) # remove temporary table
```

The resulting table, massProfilesPlus, should have exactly twice the total tonnage of massProfiles.  Moreover, within each scenario, production tons should have the same sum as end-of-life tons.  This can be checked...

```{r}
print(
  paste(
    "Total tonnage in massProfiles is ",
    sum(massProfiles$tons),
    ".",
    sep=""
  )
)

print(
  paste(
    "Total tonnage in massProfilesPlus is ",
    sum(massProfilesPlus$tons),
    ".",
    sep=""
  )
)

massProfilesPlus %>% 
  group_by(scenario) %>%
  summarise(
    prodTons=sum(ifelse(umbDisp=="production",tons,0)),
    eolTons=sum(ifelse(umbDisp!="production",tons,0))
  ) %>%
  print()

```

The tonnages associated with end-of-life transport are still missing, but they will be generated during the following merge of massProfiles and impactFactors.  

The merge is made on unique combinations of material and disposition name.  Since the resulting file has both tons (from the massProfiles table) and impactFactor scaled to tons (from the impactFactors table), these can be multiplied to get an impact in units of impactUnits.  

Like so:

```{r}
impactsInDetail <-
  # joining all impact factors relevant to massProfiles
  left_join(  # important: use left_join not full_join
    massProfilesPlus,
    impactFactors,
    by = c("material", "disposition")
  ) %>%
  # calculating impacts with special considerations 
  # for end-of-life transport impacts
  mutate(
    # if miles is missing replace it with default value
    miles = ifelse(is.na(miles), impliedMiles, miles),
    # calculate impact 
    impact =
      case_when(
        LCstage != "endOfLifeTransport" ~ tons*impactFactor,
        LCstage == "endOfLifeTransport" ~
          tons*(miles/impliedMiles)*impactFactor
      )
  ) %>%
  arrange(impactCategory, scenario, material, LCstage, disposition)
```

This creates a data frame, impactsInDetail, with records for each combination of scenario, wasteshed, material, LCstage, disposition, and impactCategory.  A printout of this table is relatively lengthy:

```{r}
kable(
  impactsInDetail
)
```

Some things to note about the impactsInDetails table:

* Each line is labeled with the *umbDisp* from massProfiles, so distinctions can be made between recovery and disposal impacts or tonnages if desired.
* There are 3 LCstages (production, end-of-life transport, and end-of-life treatment) represented in impactsInDetail.  The properties of the left_join merge have created the records needed to represent the (hitherto missing) end-of-life transport stage.  Since in every impact category, each material & end-of-life disposition has *two* records in impactFactors (one for the LCstage endOfLife and another for endOfLifeTransport), a left_join has added tonnages related to end-of-life transport.

### Checking the internal consistency of *impactsInDetail*

Before using the impactsInDetail file to calculate results, some basic quality checks should be performed.  

For example, tonnages associated with all life cycles should have the same value within each scenario.  That is, within each scenario, tons for "production" should be the same as tons for "endOfLifeTransport" and "endOfLife".  Code like the following can confirm that:

```{r}
impactsInDetail %>%
  group_by(LCstage, scenario) %>%
  summarise(tons=sum(tons)) %>%
  arrange(scenario, LCstage) %>%
  kable()
```
Note that tonnages in the table above are not identical to tonnages listed in the massProfiles table.  Besides the recent addition of production-related tons, and end-of-life transport tons, impactsInDetails has a complete set of tons for every impactCategory in use.

It is also valuable to check that every record has an impact factor. No impact factors should be missing, and any that are zero should be viewed with suspicion (because impactFactors of exactly zero are unlikely, and may represent a computation error or lazy assumption).  In addition, impact and tons may be zero but should not be missing.  These things can be checked with code like this:

```{r}
impactsInDetail %>% 
  filter(is.na(impactFactor) | impactFactor==0) %>%
  nrow()
impactsInDetail %>%
  filter(is.na(impact)) %>%
  nrow()
impactsInDetail %>%
  filter(is.na(tons)) %>%
  nrow()
  
```

In each of these cases, the nrow() call has output 0. This means that our impactsInDetail table has passed these particular quality checks.  If nrow() output >1, then it would be necessary to backtrack and correct something.

When impactsInDetail fails such simple internal-consistency checks, it is likely to be the result of mismatches between the massProfiles and impactFactors tables.  Spellings of material and disposition names must match exactly, and every field in every table (with the exception of the *miles* field) must be filled in with a reasonable value.

### Creating tabular and graphical output 

##### Guidelines

The impactsInDetail data frame is the source of all future output from this analysis.  Most results of interest -- for example, the total waste tonnages and total impacts linked to each scenario -- are simple summations of tons or impacts from impactsInDetail.  

When creating results from impactsInDetail, recall that:

* there is much redundancy in this data table now:  records representing every combination of scenario, wasteshed, material, LCstage, disposition, and impactCategory.  So data must be filtered down to the desired specific content to avoid miscalculation.
* when tons are summed, they should be restricted to tons marked with the "endOfLife" LCstage.  The tons that appear in other LCstages are redundant and only serve for the calculation of the impacts of those stages.
* furthermore, when tons are summed, they should be restricted to a single impact category (it should not matter which) -- as the complete set of tonnages has been repeated for every impact category. 
* impacts should be summed only within a single impactCategory -- unless users are willing to create, program, and defend a method for normalizing and/or summarizing across multiple impact categories.

##### Some utility objects

For the purpose of creating charts and tables, a few miscellaneous objects could be useful:

* a plaintext list of material names, sorted in descending order of abundance. (While the current example analysis has only 2 materials, most WIC analysese will be considerably more involved.)
* a table of likely impact category labels.  (Impact categories like "Energy demand" do not currently include physical units, such as "MJ" for megajoules.  An impact category label would merge those for use on chart axes.)
* a graphical theme for charts
* an ordered list of scenario names

Creating those things...

```{r}
# most abundant materials in the wastestream, in order
materialSortOrder <-
  massProfiles %>%
  group_by(material) %>%
  summarise(tons=sum(tons)) %>%
  arrange(desc(tons)) %>%
  pull(material)
# a table of impact categories combined with units
# (for use in chart labels)
impactLabels <-
  impactFactors %>%
  select(impactCategory, impactUnits) %>%
  distinct() %>%
  mutate(
    impactLabel = 
      paste(
        impactCategory,
        " (",
        impactUnits,
        ")",
        sep=""
      )
  )
# a custom graphic theme for charts, inspired by 
# the fivethirtyeight theme
theme_539 <- function() {
  theme_fivethirtyeight() +
  theme(
    rect=element_rect(fill="transparent"),
    panel.grid = element_blank(),
    axis.ticks = element_line()
  )
}

# making an ordered list of scenarios, where "baseline" is first
scenarioOrder <- 
  c(
    "baseline",
    setdiff(
        massProfiles %>% 
        select(scenario) %>% 
        distinct() %>% 
        pull(scenario),
      "baseline")
  )
```

##### Weights of waste in each of the scenarios

Note that when weights are summed, only the "endOfLife" LCstage is used, and only a single impactCategory is used.

```{r}
# summing weights by disposition for each scenario
tempWeightData1 <- 
  impactsInDetail %>%
  filter(
    LCstage == "endOfLife" & impactCategory=="Energy demand"
    ) %>% # correct set for weight calculations
  group_by(scenario, disposition) %>% 
  summarise(tons=sum(tons)) %>%
  ungroup() %>%
  filter(tons != 0) %>%
  mutate(scenario= factor(scenario, levels=rev(scenarioOrder)))
kable(tempWeightData1)
```

making that weight data into a chart...

```{r fig.width=6.5, fig.height=4.5}
tempWeightChart1 <-
  ggplot()+
  ggtitle("Weight (short tons)")+
  theme_539()+
  geom_bar(
    data = tempWeightData1,
    aes(x = scenario, y= tons, fill= disposition),
    color=NA,
    stat="identity"
  )+
  scale_fill_viridis(begin=0.5, end=1, discrete = TRUE, option="D", direction=1)+
  coord_flip()+
  guides(fill=guide_legend(ncol=2, title.position = "top"))+
  theme(
    rect=element_rect(fill="transparent"),
    plot.title = element_text(size=12),
    legend.position="bottom",
    legend.title = element_text(size=8),
    legend.justification="left"
    )
# printing the chart to the current device
tempWeightChart1
# saving the chart as external files
ggsave("chart_output/weights.png")
ggsave("chart_output/weights.svg")
```

##### Life cycle impacts for waste in each scenario

Now for comparison, let's look at the impacts associated with those scenarios.  But here we will have to deal with more voluminous output, because there are multiple impact categories.

First, sum up the impacts in similar detail to the weight chart:
```{r}
tempImpactData1 <-
  impactsInDetail %>%
  group_by(scenario, impactCategory, impactUnits) %>%
  summarise(impact=sum(impact)) %>%
  ungroup() %>%
  mutate(
    scenario = factor(scenario, levels = rev(scenarioOrder)),
    impactLabel = 
      paste(
        impactCategory,
        " (",
        impactUnits,
        ")",
        sep=""
      )
  ) 
kable(tempImpactData1)
```

For a single impactCategory, we can make an impact chart analagous to the weight chart:
```{r fig.width=6.5, fig.height=4.5}
# chose a single impactCategory at random
tempImpactCategory <- sample_n(impactLabels, 1)
# get the impacts for that category
tempImpactChart1 <-
  ggplot()+
  ggtitle(tempImpactCategory$impactLabel)+
  theme_539()+
  geom_bar(
    data = 
      tempImpactData1 %>% 
        filter(impactCategory==tempImpactCategory$impactCategory),
    aes(x = scenario, y= impact, fill=scenario),
    color=NA,
    stat="identity"
  )+
  scale_fill_viridis(begin=0.32, end=1, discrete = TRUE, option="B")+
  coord_flip()+
  guides(fill=guide_legend(ncol=2, title.position = "top"))+
  theme(
    rect=element_rect(fill="transparent"),
    plot.title = element_text(size=12),
    legend.position="none",
    legend.title = element_text(size=8),
    legend.justification="left"
    )
tempImpactChart1
ggsave("chart_output/impacts1.png")
ggsave("chart_output/impacts1.svg")
```

If we use a more complex layout, we can create a single image with facets expressing all of the available impact categories:

```{r fig.width=10, fig.height=16}
tempImpactChart1 <-
  ggplot()+
  ggtitle("Impacts of scenarios compared (print on 11x17)")+
  theme_539()+
  geom_bar(
    data = tempImpactData1,
    aes(x = scenario, y= impact, fill=scenario),
    color=NA,
    # size=2,
    stat="identity"
  )+
  geom_text(
    data=tempImpactData1,
    aes(x=scenario, y=0, label=scenario),
    color="gray80",
    size=3,
    fontface="italic",
    hjust=-0.1
  )+
  facet_wrap(~impactLabel, ncol=2, scales="free")+
  scale_fill_viridis(
    begin=0.1, end=0.7, discrete = TRUE, option="C"
  )+
  coord_flip()+
#  guides(fill=guide_legend(ncol=2, title.position = "top"))+
  theme(
    rect=element_rect(fill="transparent"),
    plot.title = element_text(size=12),
    legend.position="none",
    axis.text.x=element_text(angle=45, hjust=1),
    axis.text.y=element_blank(),
    strip.text = element_text(size=11, face="bold")
    )
tempImpactChart1
ggsave("chart_output/impacts2.png") 
ggsave("chart_output/impacts2.svg")
```
I need a similar thing, but broken down by material 

```{r, fig.width=10, fig.height=16}
tempImpactData1m <-
  impactsInDetail %>%
  group_by(scenario, material, impactCategory, impactUnits) %>%
  summarise(impact=sum(impact)) %>%
  ungroup() %>%
  mutate(
    scenario = factor(scenario, levels = rev(scenarioOrder)),
    impactLabel = 
      paste(
        impactCategory,
        " (",
        impactUnits,
        ")",
        sep=""
      )
  ) 

tempImpactChart1m <-
  ggplot()+
  ggtitle("Impacts of scenarios (by material) compared\n(print on 11x17)")+
  theme_539()+
  geom_bar(
    data = tempImpactData1m,
    aes(x = scenario, y= impact, fill=material),
    color=NA,
    # size=2,
    stat="identity"
  )+
  geom_text(
    data=tempImpactData1m,
    aes(x=scenario, y=0, label=scenario),
    color="gray80",
    size=3,
    fontface="italic",
    hjust=-0.1
  )+
  facet_wrap(~impactLabel, ncol=2, scales="free")+
  scale_fill_viridis(
    begin=0.1, end=0.7, discrete = TRUE, option="C"
  )+
  coord_flip()+
#  guides(fill=guide_legend(ncol=2, title.position = "top"))+
  theme(
    rect=element_rect(fill="transparent"),
    plot.title = element_text(size=12),
    legend.position="bottom",
    axis.text.x=element_text(angle=45, hjust=1),
    axis.text.y=element_blank(),
    strip.text = element_text(size=11, face="bold")
    )
tempImpactChart1m
ggsave("chart_output/impacts2m.png") 
ggsave("chart_output/impacts2m.svg")
```




##### Detailing weight by umbrella disposition

The charts above don't have a lot of detail about waste management.  Let's redo the weight chart so that it characterizes the weight-based recovery rate in each scenario.  For that, we sum weights by scenario and umbDisp:

```{r}
# summing weights by umbDisp for each scenario
tempWeightData2 <- 
  impactsInDetail %>%
  filter(
    LCstage == "endOfLife" & impactCategory == "Energy demand"
  ) %>% # correct set for weight calculations
  group_by(scenario, umbDisp) %>% 
  summarise(tons=sum(tons)) %>%
  ungroup() %>%
  filter(tons != 0) %>%
  mutate(scenario= factor(scenario, levels=rev(scenarioOrder))) %>%
  group_by(scenario) %>%
  mutate(recovTons=ifelse(umbDisp=="recovery",tons,0)) %>%
  ungroup()
kable(tempWeightData2)

# creating a data file that expresses weight-based
# recovery rate for each scenario
tempWeightData2a <-
  tempWeightData2 %>%
  group_by(scenario) %>%
  summarise(
    recovTons=sum(recovTons),
    tons=sum(tons)
  ) %>%
  ungroup() %>%
  mutate(recovRate=recovTons/tons)
kable(tempWeightData2a)
```

making that weight data into a chart...

```{r fig.width=6.5, fig.height=4.5}
tempWeightChart2 <-
  ggplot()+
  ggtitle("Weight (short tons) and recovery rates (%)")+
  theme_539()+
  geom_bar(
    data = tempWeightData2,
    aes(x = scenario, y= tons, fill= umbDisp),
    color=NA,
    stat="identity"
  )+
  geom_text(
    data=tempWeightData2a,
    aes(x=scenario, y=tons, label=percent(recovRate)),
    hjust=1.1,
    color="white"
  )+
  scale_fill_viridis(
    begin=0.32, end=0.8, option="D", discrete = TRUE
    )+
  coord_flip()+
  guides(fill=guide_legend(ncol=2, title.position = "top"))+
  theme(
    rect=element_rect(fill="transparent"),
    plot.title = element_text(size=12),
    legend.position="bottom",
    legend.title = element_text(size=8),
    legend.justification="left"
    )
tempWeightChart2
ggsave("chart_output/weights2.png")
ggsave("chart_output/weights2.svg")
```
##### Illustrating impacts by life cycle stage

Previously the impacts associated with each scenario were given only as net values -- the sum of three life cycle stages.  It can be interesting to show how those three stages contribute to the net.   To do that, we sum impacts by scenario and LCstage:

```{r}
tempImpactData2 <-
  impactsInDetail %>%
  group_by(scenario, LCstage, impactCategory, impactUnits) %>%
  summarise(impact=sum(impact)) %>%
  ungroup() %>%
  mutate(
    scenario = factor(scenario, levels = rev(scenarioOrder)),
    impactLabel = 
      paste(
        impactCategory,
        " (",
        impactUnits,
        ")",
        sep=""
      ),
    LCstage=
      factor(
        LCstage,
        levels=c("production","endOfLife","endOfLifeTransport")
      )
  ) 
kable(tempImpactData2)
```

Now make that into a chart, with life cycle stage impacts in colors, and  the (previously calculated) net impact as a black outline.
```{r fig.width=10, fig.height=16}
tempImpactChart2 <-
  ggplot()+
  ggtitle("Impacts of scenarios with life cycle stage detail\n(print on 11x17)")+
  theme_539()+
  geom_bar(
    data = tempImpactData2,
    aes(x = scenario, y= impact, fill=LCstage),
    color=NA,
    # size=2,
    stat="identity"
  )+
  geom_bar(
    data=tempImpactData1 %>% mutate(LCstage="Net"),
    aes(x=scenario, y=impact, color=LCstage),
    stat="identity",
    fill=NA,
    size=2
  )+
  geom_text(
    data=tempImpactData1 %>% mutate(LCstage="Net"),
    aes(x=scenario, y=0, label=scenario),
    stat="identity",
    color="gray20",
    size=3,
    fontface="italic",
    hjust=-0.1,
    vjust=0.5
  )+
  facet_wrap(~impactLabel, ncol=2, scales="free")+
  scale_color_manual(values="black")+
  scale_fill_viridis(
    begin=0.32, end=0.95, option="E", discrete = TRUE,
    direction = -1
  )+
  coord_flip()+
  guides(
    color=guide_legend(nrow=1, title=NULL),
    fill=guide_legend(nrow=1, title.position = "left")
    )+
  theme(
    rect=element_rect(fill="transparent"),
    plot.title = element_text(size=12),
    legend.position="top",
    axis.text.x=element_text(angle=45, hjust=1),
    axis.text.y=element_blank(),
    strip.text = element_text(size=11, face="bold")
    )
tempImpactChart2
ggsave("chart_output/impacts3.png") 
ggsave("chart_output/impacts3.svg")
```

The chart above shows that, at least in this analysis, production impacts (the tan color) make by far the biggest contribution to the net impact (black outline).  End-of-life credits are visible, in the "recover_nearly_all" scenario, but they are smaller than many might guess.  End-of-life transport impacts are so small they are not visible, probably obscured by the black "net" line.

##### Heatmap

Another way to compare impact results across scenarios is the "heatmap", where all impacts are scaled to the baseline value.

Here is the code to produce a data table which can be drawn as a heatmap:

```{r}
tempImpactData3 <-
  tempImpactData1 %>% 
  filter(scenario=="baseline") %>%
  select(impactLabel, impact) %>%
  rename(baselineImpact=impact)
tempImpactData3a <-
  left_join(
    tempImpactData1,
    tempImpactData3,
    by= c("impactLabel")
  ) %>%
  mutate(
    pctBaselineImpact=impact/baselineImpact
  )
kable(tempImpactData3a)
```

now, to make that into a chart:

```{r fig.width=6.5, fig.height=4.5}
tempImpactChart3 <-
  ggplot()+
  ggtitle("Heatmap of scenario impacts (as % of baseline)")+
  theme_539()+
  geom_tile(
    data=tempImpactData3a,
    aes(y=scenario, x=impactLabel, fill=pctBaselineImpact),
    color="white"
  )+
  geom_text(
    data=tempImpactData3a,
    aes(
      y=scenario, x=impactLabel, label=percent(pctBaselineImpact,1)
    ),
    color="white",
    size=2
  )+
  scale_fill_viridis(begin=0.2, end=0.7, option="A")+
  theme(
    plot.title = element_text(size=12),
    rect=element_rect(fill="transparent"),
    panel.grid = element_blank(),
    axis.ticks = element_line(),
    axis.text.x = element_text(hjust=1, angle=45)
  )
tempImpactChart3
ggsave("chart_output/impacts4.png")
ggsave("chart_output/impacts4.svg")
```

In this display, the darker colors indicate for the  eliminate_food_waste scenario show a dramatic effect on water consumption, and a notable effect on energy demand.  Shades of orange for the recover_nearly_all scenario show much more modest effects, compared to the baseline scenario.

Though this heatmap is very simple -- just 6 numbers -- this kind of display can be useful for identifying "hotspots" and gradients within grids of dozen or hundreds of numbers.
